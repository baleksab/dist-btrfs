/* tslint:disable */
/* eslint-disable */
/**
 * Btrfs Backup System API
 * API documentation
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BtrfsSnapshotCleanupRequest {
    'type': BtrfsSnapshotCleanupRequestTypeEnum;
    'keep': number;
}

export const BtrfsSnapshotCleanupRequestTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type BtrfsSnapshotCleanupRequestTypeEnum = typeof BtrfsSnapshotCleanupRequestTypeEnum[keyof typeof BtrfsSnapshotCleanupRequestTypeEnum];

export interface BtrfsSnapshotCleanupResponse {
    'cleaned': boolean;
    'kept': Array<string>;
    'deletedSnapshots': Array<string>;
    'totalBefore': number;
    'totalAfter': number;
}
export interface BtrfsSnapshotDeleteResponse {
    'path': string;
    'deleted': boolean;
    'message': string;
}
export interface BtrfsSnapshotFullReplicationRequest {
    'secondaryServers': Array<string>;
}
export interface BtrfsSnapshotFullReplicationResponse {
    'snapshotPath': string;
    'results': Array<BtrfsSnapshotFullReplicationResponseResultsInner>;
}
export interface BtrfsSnapshotFullReplicationResponseResultsInner {
    'serverUid': string;
    'address': string;
    'port'?: number;
    'status': BtrfsSnapshotFullReplicationResponseResultsInnerStatusEnum;
    'error'?: string;
}

export const BtrfsSnapshotFullReplicationResponseResultsInnerStatusEnum = {
    Ok: 'ok',
    Failed: 'failed'
} as const;

export type BtrfsSnapshotFullReplicationResponseResultsInnerStatusEnum = typeof BtrfsSnapshotFullReplicationResponseResultsInnerStatusEnum[keyof typeof BtrfsSnapshotFullReplicationResponseResultsInnerStatusEnum];

export interface BtrfsSnapshotIncrementalReplicationRequest {
    'secondaryServer': string;
    'secondaryServersSnapshot': string;
}
export interface BtrfsSnapshotResponse {
    'name': string;
    'path': string;
    'createdAt'?: string;
    'sizeBytes'?: number;
}
export interface BtrfsSnapshotRestoreResponse {
    'restored': string;
    'snapshotUsed': string;
    'newSubvolume': string;
}
export interface BtrfsSubvolumeConfigResponse {
    'id': string;
    'serverUid': string;
    'subvolPath': string;
    'snapshotIntervalSeconds': number;
    'isEnabled'?: boolean;
    'exists'?: boolean;
}
export interface BtrfsSubvolumeRetentionConfigResponse {
    'id': string;
    'serverUid': string;
    'subvolPath': string;
    'type': BtrfsSubvolumeRetentionConfigResponseTypeEnum;
    'keep': number;
    'retentionIntervalSeconds': number;
    'exists'?: boolean;
    'isEnabled'?: boolean;
}

export const BtrfsSubvolumeRetentionConfigResponseTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type BtrfsSubvolumeRetentionConfigResponseTypeEnum = typeof BtrfsSubvolumeRetentionConfigResponseTypeEnum[keyof typeof BtrfsSubvolumeRetentionConfigResponseTypeEnum];

export interface BtrfsSubvolumeSetConfigRequest {
    'snapshotIntervalSeconds': number;
    'isEnabled'?: boolean;
}
export interface BtrfsSubvolumeSetRetentionConfigRequest {
    'type': BtrfsSubvolumeSetRetentionConfigRequestTypeEnum;
    'keep': number;
    'retentionIntervalSeconds': number;
    'isEnabled'?: boolean;
}

export const BtrfsSubvolumeSetRetentionConfigRequestTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type BtrfsSubvolumeSetRetentionConfigRequestTypeEnum = typeof BtrfsSubvolumeSetRetentionConfigRequestTypeEnum[keyof typeof BtrfsSubvolumeSetRetentionConfigRequestTypeEnum];

export interface BtrfsSubvolumesResponseInner {
    'id': number;
    'gen': string;
    'topLevel': string;
    'path': string;
}
export interface CreateNewServerRequest {
    'name': string;
    'ipAddress': string;
    'port'?: number;
    'username': string;
    'password': string;
    'isPrimary'?: boolean;
}
export interface CreateNewServerResponse {
    'uid': string;
    'ipAddress': string;
    'port'?: number;
    'isPrimary'?: boolean;
}
export interface GetAllServersResponse {
    'uid': string;
    'name': string;
    'ipAddress': string;
    'port'?: number;
    'isPrimary'?: boolean;
}
export interface HealthCheckRequest {
    'ipAddress': string;
    'port'?: number;
    'username': string;
    'password': string;
}
export interface HealthCheckResponse {
    'uid': string;
    'online'?: boolean;
}
export interface UpdateServerRequest {
    'name'?: string;
    'ipAddress'?: string;
    'port'?: number;
    'username'?: string;
    'password'?: string;
    'isPrimary'?: boolean;
}

/**
 * BtrfsApi - axios parameter creator
 */
export const BtrfsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesConfigGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/btrfs/subvolumes/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesGet: async (serverUid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/btrfs/subvolumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serverUid !== undefined) {
                localVarQueryParameter['serverUid'] = serverUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesRetentionConfigGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/btrfs/subvolumes/retention/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeConfigGet: async (subvolume: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiBtrfsSubvolumesSubvolumeConfigGet', 'subvolume', subvolume)
            const localVarPath = `/api/btrfs/subvolumes/{subvolume}/config`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetConfigRequest} [btrfsSubvolumeSetConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeConfigPost: async (subvolume: string, btrfsSubvolumeSetConfigRequest?: BtrfsSubvolumeSetConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiBtrfsSubvolumesSubvolumeConfigPost', 'subvolume', subvolume)
            const localVarPath = `/api/btrfs/subvolumes/{subvolume}/config`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(btrfsSubvolumeSetConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeHealthGet: async (subvolume: string, serverUid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiBtrfsSubvolumesSubvolumeHealthGet', 'subvolume', subvolume)
            const localVarPath = `/api/btrfs/subvolumes/{subvolume}/health`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serverUid !== undefined) {
                localVarQueryParameter['serverUid'] = serverUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeRetentionConfigGet: async (subvolume: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiBtrfsSubvolumesSubvolumeRetentionConfigGet', 'subvolume', subvolume)
            const localVarPath = `/api/btrfs/subvolumes/{subvolume}/retention/config`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetRetentionConfigRequest} [btrfsSubvolumeSetRetentionConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeRetentionConfigPost: async (subvolume: string, btrfsSubvolumeSetRetentionConfigRequest?: BtrfsSubvolumeSetRetentionConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiBtrfsSubvolumesSubvolumeRetentionConfigPost', 'subvolume', subvolume)
            const localVarPath = `/api/btrfs/subvolumes/{subvolume}/retention/config`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(btrfsSubvolumeSetRetentionConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BtrfsApi - functional programming interface
 */
export const BtrfsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BtrfsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesConfigGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BtrfsSubvolumeConfigResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesConfigGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesGet(serverUid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BtrfsSubvolumesResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesGet(serverUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesRetentionConfigGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BtrfsSubvolumeRetentionConfigResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesRetentionConfigGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesRetentionConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesSubvolumeConfigGet(subvolume: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSubvolumeConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesSubvolumeConfigGet(subvolume, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesSubvolumeConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetConfigRequest} [btrfsSubvolumeSetConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesSubvolumeConfigPost(subvolume: string, btrfsSubvolumeSetConfigRequest?: BtrfsSubvolumeSetConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSubvolumeConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesSubvolumeConfigPost(subvolume, btrfsSubvolumeSetConfigRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesSubvolumeConfigPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesSubvolumeHealthGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesSubvolumeHealthGet(subvolume, serverUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesSubvolumeHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSubvolumeRetentionConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesSubvolumeRetentionConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetRetentionConfigRequest} [btrfsSubvolumeSetRetentionConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume: string, btrfsSubvolumeSetRetentionConfigRequest?: BtrfsSubvolumeSetRetentionConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSubvolumeRetentionConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume, btrfsSubvolumeSetRetentionConfigRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BtrfsApi.apiBtrfsSubvolumesSubvolumeRetentionConfigPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BtrfsApi - factory interface
 */
export const BtrfsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BtrfsApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesConfigGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<BtrfsSubvolumeConfigResponse>> {
            return localVarFp.apiBtrfsSubvolumesConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesGet(serverUid?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BtrfsSubvolumesResponseInner>> {
            return localVarFp.apiBtrfsSubvolumesGet(serverUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesRetentionConfigGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<BtrfsSubvolumeRetentionConfigResponse>> {
            return localVarFp.apiBtrfsSubvolumesRetentionConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeConfigGet(subvolume: string, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSubvolumeConfigResponse> {
            return localVarFp.apiBtrfsSubvolumesSubvolumeConfigGet(subvolume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetConfigRequest} [btrfsSubvolumeSetConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeConfigPost(subvolume: string, btrfsSubvolumeSetConfigRequest?: BtrfsSubvolumeSetConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSubvolumeConfigResponse> {
            return localVarFp.apiBtrfsSubvolumesSubvolumeConfigPost(subvolume, btrfsSubvolumeSetConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeHealthGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.apiBtrfsSubvolumesSubvolumeHealthGet(subvolume, serverUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume: string, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSubvolumeRetentionConfigResponse> {
            return localVarFp.apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSubvolumeSetRetentionConfigRequest} [btrfsSubvolumeSetRetentionConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume: string, btrfsSubvolumeSetRetentionConfigRequest?: BtrfsSubvolumeSetRetentionConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSubvolumeRetentionConfigResponse> {
            return localVarFp.apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume, btrfsSubvolumeSetRetentionConfigRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BtrfsApi - object-oriented interface
 */
export class BtrfsApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesConfigGet(options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [serverUid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesGet(serverUid?: string, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesGet(serverUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesRetentionConfigGet(options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesRetentionConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesSubvolumeConfigGet(subvolume: string, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesSubvolumeConfigGet(subvolume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {BtrfsSubvolumeSetConfigRequest} [btrfsSubvolumeSetConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesSubvolumeConfigPost(subvolume: string, btrfsSubvolumeSetConfigRequest?: BtrfsSubvolumeSetConfigRequest, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesSubvolumeConfigPost(subvolume, btrfsSubvolumeSetConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} [serverUid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesSubvolumeHealthGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesSubvolumeHealthGet(subvolume, serverUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume: string, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesSubvolumeRetentionConfigGet(subvolume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {BtrfsSubvolumeSetRetentionConfigRequest} [btrfsSubvolumeSetRetentionConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume: string, btrfsSubvolumeSetRetentionConfigRequest?: BtrfsSubvolumeSetRetentionConfigRequest, options?: RawAxiosRequestConfig) {
        return BtrfsApiFp(this.configuration).apiBtrfsSubvolumesSubvolumeRetentionConfigPost(subvolume, btrfsSubvolumeSetRetentionConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemoteServersApi - axios parameter creator
 */
export const RemoteServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersHealthCheckGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/servers/healthCheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {CreateNewServerRequest} [createNewServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersPost: async (createNewServerRequest?: CreateNewServerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersUidDelete: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('apiServersUidDelete', 'uid', uid)
            const localVarPath = `/api/servers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {UpdateServerRequest} [updateServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersUidPut: async (uid: string, updateServerRequest?: UpdateServerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('apiServersUidPut', 'uid', uid)
            const localVarPath = `/api/servers/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {HealthCheckRequest} [healthCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersValidatePost: async (healthCheckRequest?: HealthCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/servers/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(healthCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteServersApi - functional programming interface
 */
export const RemoteServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllServersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersHealthCheckGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HealthCheckResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersHealthCheckGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersHealthCheckGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {CreateNewServerRequest} [createNewServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersPost(createNewServerRequest?: CreateNewServerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNewServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersPost(createNewServerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersUidDelete(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersUidDelete(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersUidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {UpdateServerRequest} [updateServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersUidPut(uid: string, updateServerRequest?: UpdateServerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersUidPut(uid, updateServerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersUidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {HealthCheckRequest} [healthCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServersValidatePost(healthCheckRequest?: HealthCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServersValidatePost(healthCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteServersApi.apiServersValidatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RemoteServersApi - factory interface
 */
export const RemoteServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteServersApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllServersResponse>> {
            return localVarFp.apiServersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersHealthCheckGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<HealthCheckResponse>> {
            return localVarFp.apiServersHealthCheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {CreateNewServerRequest} [createNewServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersPost(createNewServerRequest?: CreateNewServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateNewServerResponse> {
            return localVarFp.apiServersPost(createNewServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersUidDelete(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiServersUidDelete(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} uid 
         * @param {UpdateServerRequest} [updateServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersUidPut(uid: string, updateServerRequest?: UpdateServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiServersUidPut(uid, updateServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {HealthCheckRequest} [healthCheckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServersValidatePost(healthCheckRequest?: HealthCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse> {
            return localVarFp.apiServersValidatePost(healthCheckRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteServersApi - object-oriented interface
 */
export class RemoteServersApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersGet(options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersHealthCheckGet(options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersHealthCheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {CreateNewServerRequest} [createNewServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersPost(createNewServerRequest?: CreateNewServerRequest, options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersPost(createNewServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersUidDelete(uid: string, options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersUidDelete(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} uid 
     * @param {UpdateServerRequest} [updateServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersUidPut(uid: string, updateServerRequest?: UpdateServerRequest, options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersUidPut(uid, updateServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {HealthCheckRequest} [healthCheckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiServersValidatePost(healthCheckRequest?: HealthCheckRequest, options?: RawAxiosRequestConfig) {
        return RemoteServersApiFp(this.configuration).apiServersValidatePost(healthCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnapshotsApi - axios parameter creator
 */
export const SnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSnapshotCleanupRequest} [btrfsSnapshotCleanupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeDelete: async (subvolume: string, btrfsSnapshotCleanupRequest?: BtrfsSnapshotCleanupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeDelete', 'subvolume', subvolume)
            const localVarPath = `/api/snapshots/{subvolume}`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(btrfsSnapshotCleanupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeGet: async (subvolume: string, serverUid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeGet', 'subvolume', subvolume)
            const localVarPath = `/api/snapshots/{subvolume}`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serverUid !== undefined) {
                localVarQueryParameter['serverUid'] = serverUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumePost: async (subvolume: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumePost', 'subvolume', subvolume)
            const localVarPath = `/api/snapshots/{subvolume}`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotDelete: async (subvolume: string, snapshot: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotDelete', 'subvolume', subvolume)
            // verify required parameter 'snapshot' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotDelete', 'snapshot', snapshot)
            const localVarPath = `/api/snapshots/{subvolume}/{snapshot}`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)))
                .replace(`{${"snapshot"}}`, encodeURIComponent(String(snapshot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotFullReplicationRequest} [btrfsSnapshotFullReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotReplicationFullPost: async (subvolume: string, snapshot: string, btrfsSnapshotFullReplicationRequest?: BtrfsSnapshotFullReplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotReplicationFullPost', 'subvolume', subvolume)
            // verify required parameter 'snapshot' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotReplicationFullPost', 'snapshot', snapshot)
            const localVarPath = `/api/snapshots/{subvolume}/{snapshot}/replication/full`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)))
                .replace(`{${"snapshot"}}`, encodeURIComponent(String(snapshot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(btrfsSnapshotFullReplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotIncrementalReplicationRequest} [btrfsSnapshotIncrementalReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost: async (subvolume: string, snapshot: string, btrfsSnapshotIncrementalReplicationRequest?: BtrfsSnapshotIncrementalReplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost', 'subvolume', subvolume)
            // verify required parameter 'snapshot' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost', 'snapshot', snapshot)
            const localVarPath = `/api/snapshots/{subvolume}/{snapshot}/replication/incremental`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)))
                .replace(`{${"snapshot"}}`, encodeURIComponent(String(snapshot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(btrfsSnapshotIncrementalReplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotRestorePost: async (subvolume: string, snapshot: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subvolume' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotRestorePost', 'subvolume', subvolume)
            // verify required parameter 'snapshot' is not null or undefined
            assertParamExists('apiSnapshotsSubvolumeSnapshotRestorePost', 'snapshot', snapshot)
            const localVarPath = `/api/snapshots/{subvolume}/{snapshot}/restore`
                .replace(`{${"subvolume"}}`, encodeURIComponent(String(subvolume)))
                .replace(`{${"snapshot"}}`, encodeURIComponent(String(snapshot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSnapshotCleanupRequest} [btrfsSnapshotCleanupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeDelete(subvolume: string, btrfsSnapshotCleanupRequest?: BtrfsSnapshotCleanupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotCleanupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeDelete(subvolume, btrfsSnapshotCleanupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BtrfsSnapshotResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeGet(subvolume, serverUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumePost(subvolume: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumePost(subvolume, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeSnapshotDelete(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeSnapshotDelete(subvolume, snapshot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeSnapshotDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotFullReplicationRequest} [btrfsSnapshotFullReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume: string, snapshot: string, btrfsSnapshotFullReplicationRequest?: BtrfsSnapshotFullReplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotFullReplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume, snapshot, btrfsSnapshotFullReplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeSnapshotReplicationFullPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotIncrementalReplicationRequest} [btrfsSnapshotIncrementalReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume: string, snapshot: string, btrfsSnapshotIncrementalReplicationRequest?: BtrfsSnapshotIncrementalReplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotFullReplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume, snapshot, btrfsSnapshotIncrementalReplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSnapshotsSubvolumeSnapshotRestorePost(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BtrfsSnapshotRestoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSnapshotsSubvolumeSnapshotRestorePost(subvolume, snapshot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.apiSnapshotsSubvolumeSnapshotRestorePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnapshotsApi - factory interface
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotsApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {BtrfsSnapshotCleanupRequest} [btrfsSnapshotCleanupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeDelete(subvolume: string, btrfsSnapshotCleanupRequest?: BtrfsSnapshotCleanupRequest, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotCleanupResponse> {
            return localVarFp.apiSnapshotsSubvolumeDelete(subvolume, btrfsSnapshotCleanupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} [serverUid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BtrfsSnapshotResponse>> {
            return localVarFp.apiSnapshotsSubvolumeGet(subvolume, serverUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumePost(subvolume: string, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotResponse> {
            return localVarFp.apiSnapshotsSubvolumePost(subvolume, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotDelete(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotDeleteResponse> {
            return localVarFp.apiSnapshotsSubvolumeSnapshotDelete(subvolume, snapshot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotFullReplicationRequest} [btrfsSnapshotFullReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume: string, snapshot: string, btrfsSnapshotFullReplicationRequest?: BtrfsSnapshotFullReplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotFullReplicationResponse> {
            return localVarFp.apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume, snapshot, btrfsSnapshotFullReplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {BtrfsSnapshotIncrementalReplicationRequest} [btrfsSnapshotIncrementalReplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume: string, snapshot: string, btrfsSnapshotIncrementalReplicationRequest?: BtrfsSnapshotIncrementalReplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotFullReplicationResponse> {
            return localVarFp.apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume, snapshot, btrfsSnapshotIncrementalReplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} subvolume 
         * @param {string} snapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSnapshotsSubvolumeSnapshotRestorePost(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig): AxiosPromise<BtrfsSnapshotRestoreResponse> {
            return localVarFp.apiSnapshotsSubvolumeSnapshotRestorePost(subvolume, snapshot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 */
export class SnapshotsApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {BtrfsSnapshotCleanupRequest} [btrfsSnapshotCleanupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeDelete(subvolume: string, btrfsSnapshotCleanupRequest?: BtrfsSnapshotCleanupRequest, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeDelete(subvolume, btrfsSnapshotCleanupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} [serverUid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeGet(subvolume: string, serverUid?: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeGet(subvolume, serverUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumePost(subvolume: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumePost(subvolume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} snapshot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeSnapshotDelete(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeSnapshotDelete(subvolume, snapshot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} snapshot 
     * @param {BtrfsSnapshotFullReplicationRequest} [btrfsSnapshotFullReplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume: string, snapshot: string, btrfsSnapshotFullReplicationRequest?: BtrfsSnapshotFullReplicationRequest, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeSnapshotReplicationFullPost(subvolume, snapshot, btrfsSnapshotFullReplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} snapshot 
     * @param {BtrfsSnapshotIncrementalReplicationRequest} [btrfsSnapshotIncrementalReplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume: string, snapshot: string, btrfsSnapshotIncrementalReplicationRequest?: BtrfsSnapshotIncrementalReplicationRequest, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeSnapshotReplicationIncrementalPost(subvolume, snapshot, btrfsSnapshotIncrementalReplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} subvolume 
     * @param {string} snapshot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiSnapshotsSubvolumeSnapshotRestorePost(subvolume: string, snapshot: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).apiSnapshotsSubvolumeSnapshotRestorePost(subvolume, snapshot, options).then((request) => request(this.axios, this.basePath));
    }
}



